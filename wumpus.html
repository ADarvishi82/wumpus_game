<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø¨Ø§Ø²ÛŒ Wumpus Ø¨Ø§ Ø­Ø±Ú©Øª Ø¶Ø±Ø¨Ø¯Ø±ÛŒ</title>
    <style>
        body {
            font-family: 'Tahoma', sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
        }

        .game-area {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .info-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            height: fit-content;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            background: #333;
            border-radius: 10px;
            padding: 10px;
            margin: 20px 0;
        }

        .cell {
            aspect-ratio: 1;
            background: linear-gradient(145deg, #4a4a4a, #2d2d2d);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.3s ease;
            font-size: 10px;
            color: white;
            border: 2px solid transparent;
            min-height: 60px;
        }

        .cell:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }

        .cell.visited {
            background: linear-gradient(145deg, #2d5a2d, #1a3d1a);
            border-color: #4a7c59;
        }

        .cell.agent {
            background: linear-gradient(145deg, #2d5a87, #1a3d5a);
            border-color: #4a7cff;
            box-shadow: 0 0 20px rgba(74, 124, 255, 0.5);
        }

        .cell.breeze {
            background: linear-gradient(145deg, #5a5a2d, #3d3d1a);
            border-color: #7c7c4a;
        }

        .cell.stench {
            background: linear-gradient(145deg, #5a2d2d, #3d1a1a);
            border-color: #7c4a4a;
        }

        .cell.gold {
            background: linear-gradient(145deg, #ffd700, #cc8400);
            border-color: #ffed4a;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .cell-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 20px 0;
        }

        .btn {
            background: linear-gradient(145deg, #4a90e2, #357abd);
            border: none;
            border-radius: 8px;
            color: white;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: bold;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .reasoning {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid #4a90e2;
        }

        .knowledge-base {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            max-height: 200px;
            overflow-y: auto;
        }

        .status {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }

        .keyboard-controls {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
        }

        .keyboard-controls kbd {
            background: linear-gradient(145deg, #555, #333);
            border: 1px solid #777;
            border-radius: 4px;
            padding: 4px 8px;
            font-family: monospace;
            font-weight: bold;
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .emoji {
            font-size: 16px;
        }

        h3 {
            margin-top: 0;
            color: #4a90e2;
        }

        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .game-over-content {
            background: linear-gradient(145deg, #2c3e50, #34495e);
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            max-width: 400px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="game-area">
            <h2>ğŸ¹ Ø¨Ø§Ø²ÛŒ Wumpus Ø¨Ø§ Ø­Ø±Ú©Øª Ø¶Ø±Ø¨Ø¯Ø±ÛŒ</h2>
            
            <div class="grid" id="grid"></div>
            
            <div class="keyboard-controls">
                <h3>âŒ¨ï¸ Ú©Ù†ØªØ±Ù„â€ŒÙ‡Ø§:</h3>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; text-align: center; font-size: 14px;">
                    <div><kbd>W</kbd><br>Ø¨Ø§Ù„Ø§</div>
                    <div><kbd>E</kbd><br>Ø¨Ø§Ù„Ø§-Ø±Ø§Ø³Øª</div>
                    <div><kbd>Q</kbd><br>Ø¨Ø§Ù„Ø§-Ú†Ù¾</div>
                    <div><kbd>A</kbd><br>Ú†Ù¾</div>
                    <div><kbd>S</kbd><br>Ù¾Ø§ÛŒÛŒÙ†</div>
                    <div><kbd>D</kbd><br>Ø±Ø§Ø³Øª</div>
                    <div><kbd>Z</kbd><br>Ù¾Ø§ÛŒÛŒÙ†-Ú†Ù¾</div>
                    <div><kbd>X</kbd><br>Ù¾Ø§ÛŒÛŒÙ†-Ø±Ø§Ø³Øª</div>
                    <div><kbd>Space</kbd><br>ğŸ¹ ØªÛŒØ±</div>
                    <div><kbd>G</kbd><br>ğŸ’° Ø·Ù„Ø§</div>
                    <div><kbd>R</kbd><br>ğŸ² Ø¨Ø§Ø²ÛŒ Ø¬Ø¯ÛŒØ¯</div>
                </div>
            </div>

            <div class="reasoning" id="reasoning">
                <h3>ğŸ§  Ø§Ø³ØªØ¯Ù„Ø§Ù„ Ø­Ø±Ú©Øª Ø¨Ø¹Ø¯ÛŒ:</h3>
                <p>Ø¨Ø§Ø²ÛŒ Ø´Ø±ÙˆØ¹ Ø´Ø¯. Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø­ÛŒØ· Ø§Ø·Ø±Ø§Ù...</p>
            </div>
        </div>

        <div class="info-panel">
            <div class="status">
                <h3>ğŸ“Š ÙˆØ¶Ø¹ÛŒØª Ø¨Ø§Ø²ÛŒ</h3>
                <p>Ù…ÙˆÙ‚Ø¹ÛŒØª: <span id="position">(1,1)</span></p>
                <p>ØªÛŒØ±Ù‡Ø§: <span id="arrows">3</span></p> <!-- Updated arrows -->
                <p>Ø·Ù„Ø§: <span id="gold">0/3</span></p> <!-- Updated gold status -->
                <p>Ø§Ù…ØªÛŒØ§Ø²: <span id="score">0</span></p>
            </div>

            <div class="knowledge-base">
                <h3>ğŸ“š Ù¾Ø§ÛŒÚ¯Ø§Ù‡ Ø¯Ø§Ù†Ø´ (FOL)</h3>
                <div id="knowledge">
                    <p>Safe(1,1) â† Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒ</p>
                    <p>Agent(1,1) â† Ù…ÙˆÙ‚Ø¹ÛŒØª ÙØ¹Ù„ÛŒ</p>
                </div>
            </div>

            <div class="status">
                <h3>ğŸ” Ø¹Ù„Ø§Ø¦Ù… Ù…Ø­Ø³ÙˆØ³</h3>
                <div id="percepts">
                    <p>Ù‡ÛŒÚ† Ø¹Ù„Ø§Ù…ØªÛŒ Ø§Ø­Ø³Ø§Ø³ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯</p>
                </div>
            </div>

            <div class="status">
                <h3>ğŸ“– Ø±Ø§Ù‡Ù†Ù…Ø§</h3>
                <p>ğŸŒªï¸ Ù†Ø³ÛŒÙ…: Ú¯ÙˆØ¯Ø§Ù„ Ù†Ø²Ø¯ÛŒÚ© Ø§Ø³Øª</p>
                <p>ğŸ’¨ Ø¨ÙˆÛŒ Ø¨Ø¯: Wumpus Ù†Ø²Ø¯ÛŒÚ© Ø§Ø³Øª</p>
                <p>âœ¨ Ø¯Ø±Ø®Ø´Ø´: Ø·Ù„Ø§ Ø¯Ø± Ø§ÛŒÙ†Ø¬Ø§Ø³Øª</p>
                <p>ğŸ¹ Agent: Ù…ÙˆÙ‚Ø¹ÛŒØª Ø´Ù…Ø§</p>
            </div>
        </div>
    </div>

    <script>
        class WumpusGame {
            constructor() {
                this.size = 8;
                this.agentPos = [0, 0]; // (row, col) 0-indexed
                this.numWumpuses = 3; // Added number of wumpuses
                this.numGold = 3; // Added number of gold pieces
                this.arrows = this.numWumpuses; // Arrows equal to number of wumpuses
                this.goldCollected = 0; // Track collected gold
                this.gameOver = false;
                this.score = 0;
                this.visited = new Set();
                this.knowledge = new Set();
                this.initialSafe = new Set(); // Stores the starting cell
                this.notWumpus = new Set();
                this.notPit = new Set();
                this.dangerous = new Set();
                this.lastAgentPos = null; // Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ø­Ù„Ù‚Ù‡ Ø¨Ø§Ø²Ú¯Ø´Øª ÙÙˆØ±ÛŒ
                
                this.generateRandomWorld();
                this.initializeKnowledge();
                this.setupKeyboardControls();
                this.render();
                this.updateReasoning();
            }

            setupKeyboardControls() {
                document.addEventListener('keydown', (event) => {
                    if (this.gameOver) return;
                    
                    const key = event.key.toLowerCase();
                    event.preventDefault();
                    
                    switch(key) {
                        case 'w': this.move('up'); break;
                        case 'a': this.move('left'); break;
                        case 's': this.move('down'); break;
                        case 'd': this.move('right'); break;
                        case 'q': this.move('up-left'); break;
                        case 'e': this.move('up-right'); break;
                        case 'z': this.move('down-left'); break;
                        case 'x': this.move('down-right'); break;
                        case ' ': this.shoot(); break;
                        case 'g': this.grab(); break;
                        case 'r': startNewGame(); break;
                    }
                });
            }

            generateRandomWorld() {
                // Clear previous positions
                this.wumpusPos = []; // Changed to array
                this.pits = [];
                this.goldPos = []; // Changed to array
                
                // Generate all possible positions except (0,0) where agent starts
                const availablePositions = [];
                for (let row = 0; row < this.size; row++) {
                    for (let col = 0; col < this.size; col++) {
                        if (!(row === 0 && col === 0)) {
                            availablePositions.push([row, col]);
                        }
                    }
                }
                
                // Shuffle positions
                this.shuffleArray(availablePositions);
                
                // Place Wumpuses randomly
                for (let i = 0; i < this.numWumpuses && availablePositions.length > 0; i++) {
                    this.wumpusPos.push(availablePositions.pop());
                }
                
                // Place Gold randomly
                for (let i = 0; i < this.numGold && availablePositions.length > 0; i++) {
                     this.goldPos.push(availablePositions.pop());
                }
                
                // Place 4-6 pits randomly
                const numPits = Math.floor(Math.random() * 3) + 4; // 4-6 pits
                for (let i = 0; i < numPits && availablePositions.length > 0; i++) {
                    this.pits.push(availablePositions.pop());
                }

                // Ensure Wumpuses, Gold, and Pits are not in the starting cell (0,0)
                // This is already handled by generating availablePositions excluding (0,0)
                // Also ensure they don't overlap, which is handled by popping from shuffled array

                console.log("ğŸ² Ù†Ù‚Ø´Ù‡ Ø¬Ø¯ÛŒØ¯ ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯:");
                console.log(`ğŸ¹ Agent: (1,1)`);
                console.log(`ğŸ‘¹ Wumpuses: ${this.wumpusPos.map(([r,c]) => `(${r+1},${c+1})`).join(', ')}`); // Updated log
                console.log(`ğŸ’° Gold: ${this.goldPos.map(([r,c]) => `(${r+1},${c+1})`).join(', ')}`); // Updated log
                console.log(`ğŸ•³ï¸ Pits: ${this.pits.map(([r,c]) => `(${r+1},${c+1})`).join(', ')}`);
            }
            
            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            initializeKnowledge() {
                this.knowledge.add("Safe(1,1)");
                this.knowledge.add("Agent(1,1)");
                const startKey = `${this.agentPos[0]},${this.agentPos[1]}`;
                this.initialSafe.add(startKey);
                this.notWumpus.add(startKey); // Start cell has no Wumpus
                this.notPit.add(startKey);    // Start cell has no Pit
                this.visited.add(startKey);
                this.knowledge.add(`Â¬Wumpus(1,1) âˆ§ Â¬Pit(1,1) â† Start`);
            }

            getPercepts() {
                const [row, col] = this.agentPos;
                const percepts = [];
                
                // Check for breeze (adjacent to pit)
                if (this.isAdjacentToPit(row, col)) {
                    percepts.push("Breeze");
                }
                
                // Check for stench (adjacent to any wumpus)
                if (this.isAdjacentToWumpus(row, col)) { // Updated check
                    percepts.push("Stench");
                }
                
                // Check for glitter (gold in same cell)
                if (this.isGold(row, col)) { // Updated check
                    percepts.push("Glitter");
                }
                
                return percepts;
            }

            isAdjacentToPit(row, col) {
                return this.pits.some(([pr, pc]) => 
                    Math.abs(pr - row) + Math.abs(pc - col) === 1
                );
            }

            isAdjacentToWumpus(row, col) {
                 // Check if adjacent to *any* wumpus
                return this.wumpusPos.some(([wr, wc]) => 
                    Math.abs(wr - row) + Math.abs(wc - col) === 1
                );
            }

            updateKnowledge() {
                const [row, col] = this.agentPos;
                const percepts = this.getPercepts();
                const currentPosKey = `${row},${col}`;
                const currentPosDisplay = `${row + 1},${col + 1}`;

                // Agent is at currentPosDisplay, so it's visited and known not to be a Wumpus/Pit itself
                this.knowledge.add(`Agent(${currentPosDisplay})`);
                if (!this.notWumpus.has(currentPosKey)) this.notWumpus.add(currentPosKey);
                if (!this.notPit.has(currentPosKey)) this.notPit.add(currentPosKey);

                const orthogonalAdjacentCells = this.getAdjacentCells(row, col, false); // Percepts are orthogonal

                if (percepts.includes("Breeze")) {
                    this.knowledge.add(`Breeze(${currentPosDisplay})`);
                    this.knowledge.add(`âˆƒx,y: OrthoAdjacent(${currentPosDisplay}, x,y) âˆ§ Pit(x,y)`);

                    const pitCandidates = orthogonalAdjacentCells.filter(([ar, ac]) => {
                        const key = `${ar},${ac}`;
                        return !this.visited.has(key) && !this.isProvablySafe(ar, ac) && !this.notPit.has(key) && !this.dangerous.has(key);
                    });
                    if (pitCandidates.length === 1) {
                        const [pr, pc] = pitCandidates[0];
                        const pitKey = `${pr},${pc}`;
                        if (!this.dangerous.has(pitKey)) {
                            this.dangerous.add(pitKey);
                            this.knowledge.add(`Pit(${pr + 1},${pc + 1}) â† Breeze(${currentPosDisplay}) âˆ§ UniqueOrthoCandidate`);
                            console.log(`Inferred Pit at (${pr + 1},${pc + 1})`);
                        }
                    }
                } else {
                    this.knowledge.add(`Â¬Breeze(${currentPosDisplay})`);
                    this.knowledge.add(`âˆ€x,y: OrthoAdjacent(${currentPosDisplay}, x,y) â†’ Â¬Pit(x,y)`);
                    orthogonalAdjacentCells.forEach(([ar, ac]) => {
                        const key = `${ar},${ac}`;
                        if (!this.notPit.has(key)) this.notPit.add(key);
                        this.knowledge.add(`Â¬Pit(${ar + 1},${ac + 1}) â† Â¬Breeze(${currentPosDisplay})`);
                    });
                }

                if (percepts.includes("Stench")) {
                    this.knowledge.add(`Stench(${currentPosDisplay})`);
                    this.knowledge.add(`âˆƒx,y: OrthoAdjacent(${currentPosDisplay}, x,y) âˆ§ Wumpus(x,y)`);
                    const wumpusCandidates = orthogonalAdjacentCells.filter(([ar, ac]) => {
                        const key = `${ar},${ac}`;
                        return !this.visited.has(key) && !this.isProvablySafe(ar, ac) && !this.notWumpus.has(key) && !this.dangerous.has(key);
                    });
                    if (wumpusCandidates.length === 1) {
                        const [wr, wc] = wumpusCandidates[0];
                        const wumpusKey = `${wr},${wc}`;
                        if (!this.dangerous.has(wumpusKey)) {
                            this.dangerous.add(wumpusKey);
                            this.knowledge.add(`Wumpus(${wr + 1},${wc + 1}) â† Stench(${currentPosDisplay}) âˆ§ UniqueOrthoCandidate`);
                            console.log(`Inferred Wumpus at (${wr + 1},${wc + 1})`);
                        }
                    }
                } else {
                    this.knowledge.add(`Â¬Stench(${currentPosDisplay})`);
                    this.knowledge.add(`âˆ€x,y: OrthoAdjacent(${currentPosDisplay}, x,y) â†’ Â¬Wumpus(x,y)`);
                    orthogonalAdjacentCells.forEach(([ar, ac]) => {
                        const key = `${ar},${ac}`;
                        if (!this.notWumpus.has(key)) this.notWumpus.add(key);
                        this.knowledge.add(`Â¬Wumpus(${ar + 1},${ac + 1}) â† Â¬Stench(${currentPosDisplay})`);
                    });
                }
                
                if (percepts.includes("Glitter")) {
                    this.knowledge.add(`Glitter(${pos})`);
                    this.knowledge.add(`Gold(${pos})`);
                }
                
                // Update knowledge about collected gold
                if (this.goldCollected > 0) {
                     this.knowledge.add(`HasGold(${this.goldCollected})`);
                }
                if (this.wumpusPos.length < this.numWumpuses) {
                     this.knowledge.add(`WumpusesRemaining(${this.wumpusPos.length})`);
                }
            }

            isProvablySafe(row, col) {
                const key = `${row},${col}`;
                return this.initialSafe.has(key) || (this.notWumpus.has(key) && this.notPit.has(key));
            }

            getAdjacentCells(row, col, includeDiagonal = true) { // Default true for movement logic
                const adjacent = [];
                const directions = [[-1,0], [1,0], [0,-1], [0,1]]; // Orthogonal
                
                if (includeDiagonal) {
                    directions.push([-1,-1], [-1,1], [1,-1], [1,1]); // Diagonal
                }
                
                directions.forEach(([dr, dc]) => {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    if (newRow >= 0 && newRow < this.size && newCol >= 0 && newCol < this.size) {
                        adjacent.push([newRow, newCol]);
                    }
                });
                
                return adjacent;
            }

            chooseBestMove() {
                const [row, col] = this.agentPos;
                const possibleMoves = [
                    { dir: 'up', pos: [row-1, col], name: 'Ø¨Ø§Ù„Ø§' },
                    { dir: 'down', pos: [row+1, col], name: 'Ù¾Ø§ÛŒÛŒÙ†' },
                    { dir: 'left', pos: [row, col+1], name: 'Ú†Ù¾' },       // RTL: col increases
                    { dir: 'right', pos: [row, col-1], name: 'Ø±Ø§Ø³Øª' },     // RTL: col decreases
                    { dir: 'up-left', pos: [row-1, col+1], name: 'Ø¨Ø§Ù„Ø§-Ú†Ù¾' }, // RTL
                    { dir: 'up-right', pos: [row-1, col-1], name: 'Ø¨Ø§Ù„Ø§-Ø±Ø§Ø³Øª' }, // RTL
                    { dir: 'down-left', pos: [row+1, col+1], name: 'Ù¾Ø§ÛŒÛŒÙ†-Ú†Ù¾' }, // RTL
                    { dir: 'down-right', pos: [row+1, col-1], name: 'Ù¾Ø§ÛŒÛŒÙ†-Ø±Ø§Ø³Øª' }  // RTL
                ];
                
                const validMoves = possibleMoves.filter(move => this.isValidPosition(move.pos[0], move.pos[1]));
                
                // 1. Prioritize grabbing gold if available
                if (this.isGold(row, col) && this.goldCollected < this.numGold) {
                     return {
                         move: { dir: 'grab', pos: [row, col], name: 'Ú¯Ø±ÙØªÙ† Ø·Ù„Ø§' },
                         reason: `Ø·Ù„Ø§ Ø¯Ø± Ø®Ø§Ù†Ù‡ ÙØ¹Ù„ÛŒ (${row+1},${col+1}) ÛŒØ§ÙØª Ø´Ø¯. Ú¯Ø±ÙØªÙ† Ø·Ù„Ø§ ğŸ’°`
                     };
                }

                // 2. Prioritize Unvisited Provably Safe Moves (Moved up for exploration preference)
                const provablySafeMoves = validMoves.filter(move => 
                    this.isProvablySafe(move.pos[0], move.pos[1]) &&
                    !this.dangerous.has(`${move.pos[0]},${move.pos[1]}`)
                );

                const unvisitedSafeMoves = provablySafeMoves.filter(move => 
                    !this.visited.has(`${move.pos[0]},${move.pos[1]}`)
                );
                
                if (unvisitedSafeMoves.length > 0) {
                    const nextMove = unvisitedSafeMoves[0]; // Simplest: pick first
                    return {
                        move: nextMove,
                        reason: `Ø­Ø±Ú©Øª Ø¨Ù‡ Ø®Ø§Ù†Ù‡ Ø§Ù…Ù† Ù‚Ø·Ø¹ÛŒ Ùˆ Ø¨Ø§Ø²Ø¯ÛŒØ¯ Ù†Ø´Ø¯Ù‡ ${nextMove.name} (${nextMove.pos[0]+1},${nextMove.pos[1]+1}). Ø§Ø³ØªÙ†ØªØ§Ø¬: Â¬Wumpus âˆ§ Â¬Pit.`
                    };
                }

                // 3. Suggest Shooting a Confirmed Wumpus in Line of Sight
                if (this.arrows > 0) {
                    const [currentRow, currentCol] = this.agentPos;
                    const orthogonalAdjacent = this.getAdjacentCells(currentRow, currentCol, false);

                    for (const [adjR, adjC] of orthogonalAdjacent) {
                        const adjKey = `${adjR},${adjC}`;
                        const adjDisplay = `${adjR + 1},${adjC + 1}`;
                        const isConfirmedWumpus = this.dangerous.has(adjKey) && Array.from(this.knowledge).some(k => k.startsWith(`Wumpus(${adjDisplay}`));

                        if (isConfirmedWumpus && (adjR === currentRow || adjC === currentCol)) { // In line of sight
                            return {
                                move: { dir: 'shootAction', pos: [currentRow, currentCol], name: 'ØªÛŒØ±Ø§Ù†Ø¯Ø§Ø²ÛŒ' },
                                reason: `Ø§Ù‚Ø¯Ø§Ù… Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ÛŒ: ØªÛŒØ±Ø§Ù†Ø¯Ø§Ø²ÛŒ! Wumpus Ù‚Ø·Ø¹ÛŒ Ø¯Ø± (${adjDisplay}) Ø¯Ø± Ø®Ø· Ø¢ØªØ´ Ø§Ø³Øª ğŸ¯.`
                            };
                        }
                    }
                }

                // 4. Consider Visited Provably Safe Moves (Backtracking, avoiding immediate return)
                const allVisitedSafeMoves = provablySafeMoves.filter(move =>
                    this.visited.has(`${move.pos[0]},${move.pos[1]}`)
                );

                let preferredVisitedSafeMoves = allVisitedSafeMoves;
                if (this.lastAgentPos) {
                    const lastPosKey = `${this.lastAgentPos[0]},${this.lastAgentPos[1]}`;
                    const tempNonBacktrack = allVisitedSafeMoves.filter(move =>
                        `${move.pos[0]},${move.pos[1]}` !== lastPosKey
                    );
                    if (tempNonBacktrack.length > 0) {
                        preferredVisitedSafeMoves = tempNonBacktrack;
                    }
                }

                if (preferredVisitedSafeMoves.length > 0) {
                    const nextMove = preferredVisitedSafeMoves[0]; 
                    return {
                        move: nextMove,
                        reason: `Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ø®Ø§Ù†Ù‡ Ø§Ù…Ù† Ù‚Ø·Ø¹ÛŒ Ùˆ Ø¨Ø§Ø²Ø¯ÛŒØ¯ Ø´Ø¯Ù‡ ${nextMove.name} (${nextMove.pos[0]+1},${nextMove.pos[1]+1}).`
                    };
                }
                
                // 5. Evaluate Risky/Unknown Moves
                const unknownOrRiskyMoves = validMoves.filter(move => 
                    !this.isProvablySafe(move.pos[0], move.pos[1]) &&
                    !this.dangerous.has(`${move.pos[0]},${move.pos[1]}`)
                );

                if (unknownOrRiskyMoves.length > 0) {
                    let bestRiskyMove = null;
                    let minRiskScore = Infinity;
                    let bestRiskReasons = [];

                    unknownOrRiskyMoves.forEach(move => {
                        const [nextR, nextC] = move.pos;
                        const nextKey = `${nextR},${nextC}`;
                        let currentRiskScore = 0;
                        let cellRiskReason = [];

                        // Check risk from Wumpus (orthogonally adjacent to a stench source)
                        this.visited.forEach(visitedKey => {
                            const [vr, vc] = visitedKey.split(',').map(Number);
                            if (this.getPerceptsAt(vr, vc).includes("Stench")) {
                                if (Math.abs(nextR - vr) + Math.abs(nextC - vc) === 1) { // Orthogonal adjacency
                                    if (!this.notWumpus.has(nextKey)) {
                                        currentRiskScore += 10; // High penalty for potential Wumpus
                                        cellRiskReason.push(`Ù…Ù…Ú©Ù† Ø§Ø³Øª Wumpus Ø¨Ø§Ø´Ø¯ (Ù†Ø²Ø¯ÛŒÚ© Ø¨Ù‡ Ø¨ÙˆÛŒ Ø¨Ø¯ Ø¯Ø± ${vr+1},${vc+1})`);
                                    }
                                }
                            }
                            // Check risk from Pit (orthogonally adjacent to a breeze source)
                            if (this.getPerceptsAt(vr, vc).includes("Breeze")) {
                                if (Math.abs(nextR - vr) + Math.abs(nextC - vc) === 1) { // Orthogonal adjacency
                                    if (!this.notPit.has(nextKey)) {
                                        currentRiskScore += 5; // Medium penalty for potential Pit
                                        cellRiskReason.push(`Ù…Ù…Ú©Ù† Ø§Ø³Øª Ú¯ÙˆØ¯Ø§Ù„ Ø¨Ø§Ø´Ø¯ (Ù†Ø²Ø¯ÛŒÚ© Ø¨Ù‡ Ù†Ø³ÛŒÙ… Ø¯Ø± ${vr+1},${vc+1})`);
                                    }
                                }
                            }
                        });
                        if (this.visited.has(nextKey)) currentRiskScore += 1; // Slight penalty for re-visiting risky cell

                        if (currentRiskScore < minRiskScore) {
                            minRiskScore = currentRiskScore;
                            bestRiskyMove = move;
                            bestRiskReasons = cellRiskReason;
                        } else if (currentRiskScore === minRiskScore && bestRiskyMove && !this.visited.has(nextKey) && this.visited.has(`${bestRiskyMove.pos[0]},${bestRiskyMove.pos[1]}`)) {
                            bestRiskyMove = move; // Prefer unvisited if risk is same
                            bestRiskReasons = cellRiskReason;
                        }
                    });

                    if (bestRiskyMove) {
                        let reason = `Ù‡ÛŒÚ† Ø®Ø§Ù†Ù‡ Ø§Ù…Ù† Ù‚Ø·Ø¹ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯. Ø­Ø±Ú©Øª Ø§Ø­ØªÛŒØ§Ø·â€ŒØ¢Ù…ÛŒØ² Ø¨Ù‡ ${bestRiskyMove.name} (${bestRiskyMove.pos[0]+1},${bestRiskyMove.pos[1]+1}).`;
                        if (bestRiskReasons.length > 0) reason += ` Ø¯Ù„Ø§ÛŒÙ„ Ø±ÛŒØ³Ú©: ${bestRiskReasons.join('; ')}.`;
                        else reason += ` Ø§ÛŒÙ† Ø®Ø§Ù†Ù‡ Ú©Ù…ØªØ±ÛŒÙ† Ø±ÛŒØ³Ú© Ø§Ø³ØªÙ†Ø¨Ø§Ø·ÛŒ Ø±Ø§ Ø¯Ø§Ø±Ø¯.`;
                        return { move: bestRiskyMove, reason: reason };
                    }
                }
                
                // 6. Desperation: Move to a known dangerous cell if no other options
                const dangerousButValidMoves = validMoves.filter(move => this.dangerous.has(`${move.pos[0]},${move.pos[1]}`));
                if (dangerousButValidMoves.length > 0) {
                    const nextMove = dangerousButValidMoves[0]; // Simplest: pick first
                    return {
                        move: nextMove,
                        reason: `Ù‡Ø´Ø¯Ø§Ø±: Ù‡ÛŒÚ† Ø­Ø±Ú©Øª Ø§Ù…Ù† ÛŒØ§ Ú©Ù…â€ŒØ®Ø·Ø±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯. Ù…Ø¬Ø¨ÙˆØ± Ø¨Ù‡ Ø­Ø±Ú©Øª Ø¨Ù‡ Ø®Ø§Ù†Ù‡ Ø®Ø·Ø±Ù†Ø§Ú© ${nextMove.name} (${nextMove.pos[0]+1},${nextMove.pos[1]+1})!`
                    };
                }
                
                return {
                    move: null,
                    reason: "Ù‡ÛŒÚ† Ø­Ø±Ú©Øª Ù…Ù…Ú©Ù†ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯. Ø¹Ø§Ù…Ù„ Ú¯ÛŒØ± Ú©Ø±Ø¯Ù‡ Ø§Ø³Øª!"
                };
            }

            updateReasoning() {
                const percepts = this.getPercepts();
                const bestMove = this.chooseBestMove();
                
                let reasoning = "";
                
                if (percepts.length > 0) {
                    reasoning += `Ø¹Ù„Ø§Ø¦Ù… Ù…Ø­Ø³ÙˆØ³: ${percepts.join(", ")}<br>`;
                    reasoning += `Ø§Ø³ØªÙ†ØªØ§Ø¬ Ù…Ù†Ø·Ù‚ÛŒ:<br>`;
                    
                    if (percepts.includes("Breeze")) {
                        reasoning += `â€¢ Breeze(${this.agentPos[0]+1},${this.agentPos[1]+1}) â†’ âˆƒx,y: OrthoAdjacent âˆ§ Pit(x,y)<br>`;
                    } else {
                         reasoning += `â€¢ Â¬Breeze(${this.agentPos[0]+1},${this.agentPos[1]+1}) â†’ âˆ€x,y: OrthoAdjacent â†’ Â¬Pit(x,y)<br>`;
                    }
                    if (percepts.includes("Stench")) {
                        reasoning += `â€¢ Stench(${this.agentPos[0]+1},${this.agentPos[1]+1}) â†’ âˆƒx,y: OrthoAdjacent âˆ§ Wumpus(x,y)<br>`;
                    } else {
                         reasoning += `â€¢ Â¬Stench(${this.agentPos[0]+1},${this.agentPos[1]+1}) â†’ âˆ€x,y: OrthoAdjacent â†’ Â¬Wumpus(x,y)<br>`;
                    }
                    if (percepts.includes("Glitter")) {
                        reasoning += `â€¢ Glitter(${this.agentPos[0]+1},${this.agentPos[1]+1}) â†’ Gold(${this.agentPos[0]+1},${this.agentPos[1]+1})<br>`;
                    }
                } else {
                     reasoning += `Ø¹Ù„Ø§Ø¦Ù… Ù…Ø­Ø³ÙˆØ³: Ù‡ÛŒÚ†<br>`;
                     reasoning += `Ø§Ø³ØªÙ†ØªØ§Ø¬ Ù…Ù†Ø·Ù‚ÛŒ:<br>`;
                     reasoning += `â€¢ Â¬Breeze(${this.agentPos[0]+1},${this.agentPos[1]+1}) â†’ âˆ€x,y: OrthoAdjacent â†’ Â¬Pit(x,y)<br>`;
                     reasoning += `â€¢ Â¬Stench(${this.agentPos[0]+1},${this.agentPos[1]+1}) â†’ âˆ€x,y: OrthoAdjacent â†’ Â¬Wumpus(x,y)<br>`;
                }
                
                reasoning += `<br>ØªØµÙ…ÛŒÙ… Ø¨Ø¹Ø¯ÛŒ: ${bestMove.reason}`;
                
                document.getElementById('reasoning').innerHTML = `
                    <h3>ğŸ§  Ø§Ø³ØªØ¯Ù„Ø§Ù„ Ø­Ø±Ú©Øª Ø¨Ø¹Ø¯ÛŒ:</h3>
                    <p>${reasoning}</p>
                `;
            }

            move(direction) {
                if (this.gameOver) return;
                
                this.lastAgentPos = [...this.agentPos]; // Ø°Ø®ÛŒØ±Ù‡ Ù…ÙˆÙ‚Ø¹ÛŒØª ÙØ¹Ù„ÛŒ Ù‚Ø¨Ù„ Ø§Ø² Ø­Ø±Ú©Øª

                const [row, col] = this.agentPos;
                let newRow = row, newCol = col;
                
                switch(direction) {
                    case 'up': newRow--; break;
                    case 'down': newRow++; break;
                    case 'left': newCol++; break; // Ø¨Ø±Ø§ÛŒ Ø­Ø±Ú©Øª Ø¨Ù‡ Ú†Ù¾ Ø¯Ø± RTLØŒ Ø³ØªÙˆÙ† Ø§ÙØ²Ø§ÛŒØ´ Ù…ÛŒâ€ŒÛŒØ§Ø¨Ø¯
                    case 'right': newCol--; break; // Ø¨Ø±Ø§ÛŒ Ø­Ø±Ú©Øª Ø¨Ù‡ Ø±Ø§Ø³Øª Ø¯Ø± RTLØŒ Ø³ØªÙˆÙ† Ú©Ø§Ù‡Ø´ Ù…ÛŒâ€ŒÛŒØ§Ø¨Ø¯
                    case 'up-right': newRow--; newCol--; break; // Ø¨Ø§Ù„Ø§-Ø±Ø§Ø³Øª: Ø±Ø¯ÛŒÙ Ú©Ù…ØŒ Ø³ØªÙˆÙ† Ú©Ù… (Ø¨ØµØ±ÛŒ Ø±Ø§Ø³Øª)
                    case 'up-left': newRow--; newCol++; break;  // Ø¨Ø§Ù„Ø§-Ú†Ù¾: Ø±Ø¯ÛŒÙ Ú©Ù…ØŒ Ø³ØªÙˆÙ† Ø²ÛŒØ§Ø¯ (Ø¨ØµØ±ÛŒ Ú†Ù¾)
                    case 'down-right': newRow++; newCol--; break; // Ù¾Ø§ÛŒÛŒÙ†-Ø±Ø§Ø³Øª: Ø±Ø¯ÛŒÙ Ø²ÛŒØ§Ø¯ØŒ Ø³ØªÙˆÙ† Ú©Ù… (Ø¨ØµØ±ÛŒ Ø±Ø§Ø³Øª)
                    case 'down-left': newRow++; newCol++; break; // Ù¾Ø§ÛŒÛŒÙ†-Ú†Ù¾: Ø±Ø¯ÛŒÙ Ø²ÛŒØ§Ø¯ØŒ Ø³ØªÙˆÙ† Ø²ÛŒØ§Ø¯ (Ø¨ØµØ±ÛŒ Ú†Ù¾)
                    default: return; // Invalid direction
                }
                
                if (!this.isValidPosition(newRow, newCol)) {
                    // Optionally provide feedback for invalid move
                    // console.log("Invalid move: Out of bounds");
                    this.updateReasoning(); // Re-evaluate reasoning if move is invalid
                    return;
                }
                
                this.agentPos = [newRow, newCol];
                this.visited.add(`${newRow},${newCol}`);
                this.score -= 1; // Cost of movement
                
                // Check for hazards
                if (this.isPit(newRow, newCol)) {
                    this.score -= 1000;
                    this.gameOver = true;
                    this.showGameOver("Ø´Ù…Ø§ Ø¯Ø± Ú¯ÙˆØ¯Ø§Ù„ Ø§ÙØªØ§Ø¯ÛŒØ¯! ğŸ’€");
                    return;
                }
                
                if (this.isWumpus(newRow, newCol)) { // Checks if agent is *on* a wumpus cell
                    this.score -= 1000;
                    this.gameOver = true;
                    this.showGameOver("Wumpus Ø´Ù…Ø§ Ø±Ø§ Ø®ÙˆØ±Ø¯! ğŸ‘¹");
                    return;
                }
                
                this.updateKnowledge();
                this.render();
                this.updateReasoning();

                // Check for win condition after move and updates
                this.checkWinCondition();
            }

            shoot() {
                if (this.arrows <= 0 || this.gameOver) return;
                
                this.arrows--;
                this.score -= 10;
                
                const [row, col] = this.agentPos;
                let wumpusKilled = false;
                
                // Find the first wumpus in the agent's current row or column
                const wumpusIndex = this.wumpusPos.findIndex(([wr, wc]) => wr === row || wc === col);

                if (wumpusIndex !== -1) {
                    this.score += 500;
                    this.wumpusPos.splice(wumpusIndex, 1); // Remove one wumpus
                    wumpusKilled = true;
                    alert("Wumpus Ú©Ø´ØªÙ‡ Ø´Ø¯! ğŸ¯");
                    // Update knowledge about remaining wumpuses
                    if (this.wumpusPos.length === 0) {
                         this.knowledge.add("Â¬âˆƒx,y: Wumpus(x,y)");
                    } else {
                         this.knowledge.add(`WumpusesRemaining(${this.wumpusPos.length})`);
                    }
                } else {
                     alert("ØªÛŒØ± Ø¨Ù‡ Ù‡Ø¯Ù Ù†Ø®ÙˆØ±Ø¯.");
                }
                
                this.render();
                this.updateReasoning();
                this.checkWinCondition();
            }

            grab() {
                if (this.gameOver) return;
                
                const [row, col] = this.agentPos;
                // Find the index of a gold piece at the agent's current position
                const goldIndex = this.goldPos.findIndex(([gr, gc]) => gr === row && gc === col);

                if (goldIndex !== -1) {
                    this.goldCollected++;
                    this.score += 1000;
                    this.goldPos.splice(goldIndex, 1); // Remove one gold piece
                    alert("Ø·Ù„Ø§ Ù¾ÛŒØ¯Ø§ Ø´Ø¯! ğŸ’°");
                    this.knowledge.add(`HasGold(${this.goldCollected})`);
                    this.knowledge.add(`Â¬Gold(${row+1},${col+1})`); // Gold is no longer here
                } else {
                     // Optionally provide feedback if no gold is here
                     // alert("Ø·Ù„Ø§ÛŒÛŒ Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ø¯Ø§Ø´ØªÙ† Ø§ÛŒÙ†Ø¬Ø§ Ù†ÛŒØ³Øª.");
                }
                
                this.render();
                this.updateReasoning();
                this.checkWinCondition();
            }

            isValidPosition(row, col) {
                return row >= 0 && row < this.size && col >= 0 && col < this.size;
            }

            isPit(row, col) {
                return this.pits.some(([pr, pc]) => pr === row && pc === col);
            }

            isWumpus(row, col) {
                 // Check if agent is *on* any wumpus cell
                return this.wumpusPos.some(([wr, wc]) => wr === row && wc === col);
            }

            isGold(row, col) {
                 // Check if agent is *on* any gold cell
                return this.goldPos.some(([gr, gc]) => gr === row && gc === col);
            }

            render() {
                const grid = document.getElementById('grid');
                grid.innerHTML = '';
                
                for (let row = 0; row < this.size; row++) {
                    for (let col = 0; col < this.size; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        // cell.onclick = () => this.cellClick(row, col); // Keep for debugging if needed
                        
                        let content = '';
                        let classes = ['cell'];
                        
                        if (this.visited.has(`${row},${col}`)) {
                            classes.push('visited');
                        }
                        
                        if (this.agentPos[0] === row && this.agentPos[1] === col) {
                            classes.push('agent');
                            content += '<span class="emoji">ğŸ¹</span><br>';
                        }
                        
                        // Only show percepts if the cell has been visited
                        if (this.visited.has(`${row},${col}`)) {
                            const percepts = this.getPerceptsAt(row, col);
                            if (percepts.includes("Breeze")) {
                                classes.push('breeze');
                                content += '<span class="emoji">ğŸŒªï¸</span>';
                            }
                            if (percepts.includes("Stench")) {
                                classes.push('stench');
                                content += '<span class="emoji">ğŸ’¨</span>';
                            }
                            // Glitter is only perceived *in* the cell, not adjacent
                            if (percepts.includes("Glitter")) {
                                classes.push('gold'); // Add gold class for visual cue
                                content += '<span class="emoji">âœ¨</span>';
                            }
                        }
                        
                        cell.className = classes.join(' ');
                        cell.innerHTML = `<div class="cell-content">${content}<small>(${row+1},${col+1})</small></div>`;
                        grid.appendChild(cell);
                    }
                }
                
                // Update status
                document.getElementById('position').textContent = `(${this.agentPos[0]+1},${this.agentPos[1]+1})`;
                document.getElementById('arrows').textContent = this.arrows;
                document.getElementById('gold').textContent = `${this.goldCollected}/${this.numGold}`; // Updated gold status
                document.getElementById('score').textContent = this.score;
                
                // Update knowledge base (show last 10 entries for brevity)
                const knowledgeDiv = document.getElementById('knowledge');
                knowledgeDiv.innerHTML = Array.from(this.knowledge).slice(-10).map(k => `<p>${k}</p>`).join('');
                
                // Update percepts for the *current* cell
                const currentPercepts = this.getPercepts();
                document.getElementById('percepts').innerHTML = currentPercepts.length > 0 ? 
                    currentPercepts.map(p => `<p>${p}</p>`).join('') : 
                    '<p>Ù‡ÛŒÚ† Ø¹Ù„Ø§Ù…ØªÛŒ Ø§Ø­Ø³Ø§Ø³ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯</p>';
            }

            // This method gets percepts *as if* the agent were at a given cell (row, col)
            // Used for rendering visited cells
            getPerceptsAt(row, col) {
                const percepts = [];
                
                if (this.isAdjacentToPit(row, col)) {
                    percepts.push("Breeze");
                }
                
                if (this.isAdjacentToWumpus(row, col)) {
                    percepts.push("Stench");
                }
                
                if (this.isGold(row, col)) { // Check if gold is *at* this cell
                    percepts.push("Glitter");
                }
                
                return percepts;
            }

            cellClick(row, col) {
                // For debugging - show cell info
                console.log(`Cell (${row+1},${col+1}) clicked`);
                console.log(`Visited: ${this.visited.has(`${row},${col}`)}`);
                console.log(`Provably Safe: ${this.isProvablySafe(row,col)} (notWumpus: ${this.notWumpus.has(`${row},${col}`)}, notPit: ${this.notPit.has(`${row},${col}`)})`);
                console.log(`Pit: ${this.isPit(row, col)}`);
                console.log(`Wumpus: ${this.isWumpus(row, col)}`);
                console.log(`Gold: ${this.isGold(row, col)}`);
                console.log(`Percepts: ${this.getPerceptsAt(row, col).join(', ')}`);
            }

            checkWinCondition() {
                // Win condition: Collect all gold and return to the start (1,1)
                if (this.goldCollected === this.numGold && this.agentPos[0] === 0 && this.agentPos[1] === 0) {
                    this.score += 1000; // Bonus for returning
                    this.gameOver = true;
                    this.showGameOver("Ø´Ù…Ø§ Ø¨Ø±Ù†Ø¯Ù‡ Ø´Ø¯ÛŒØ¯! ğŸ‰ ØªÙ…Ø§Ù… Ø·Ù„Ø§ Ø±Ø§ Ø¬Ù…Ø¹ Ú©Ø±Ø¯ÛŒØ¯ Ùˆ Ø¨Ù‡ Ø®Ø§Ù†Ù‡ Ø¨Ø§Ø²Ú¯Ø´ØªÛŒØ¯.");
                }
                 // Optional: Lose condition if all wumpuses are killed but gold isn't collected?
                 // Or just rely on falling in pit/eaten by wumpus. Sticking to original loss conditions.
            }

            showGameOver(message) {
                const gameOverDiv = document.createElement('div');
                gameOverDiv.className = 'game-over';
                gameOverDiv.innerHTML = `
                    <div class="game-over-content">
                        <h2>${message}</h2>
                        <p>Ø§Ù…ØªÛŒØ§Ø² Ù†Ù‡Ø§ÛŒÛŒ: ${this.score}</p>
                        <div style="margin: 20px 0;">
                            <h3>ğŸ—ºï¸ Ù†Ù‚Ø´Ù‡ Ø¨Ø§Ø²ÛŒ:</h3>
                            <p>ğŸ‘¹ Wumpuses Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡: ${this.wumpusPos.length > 0 ? this.wumpusPos.map(([r,c]) => `(${r+1},${c+1})`).join(', ') : 'Ù‡Ù…Ù‡ Ú©Ø´ØªÙ‡ Ø´Ø¯Ù†Ø¯'}</p> <!-- Updated -->
                            <p>ğŸ’° Ø·Ù„Ø§Ù‡Ø§ÛŒ Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡: ${this.goldPos.length > 0 ? this.goldPos.map(([r,c]) => `(${r+1},${c+1})`).join(', ') : 'Ù‡Ù…Ù‡ Ø¬Ù…Ø¹ Ø´Ø¯Ù†Ø¯'}</p> <!-- Updated -->
                            <p>ğŸ•³ï¸ Ú¯ÙˆØ¯Ø§Ù„â€ŒÙ‡Ø§: ${this.pits.map(([r,c]) => `(${r+1},${c+1})`).join(', ')}</p>
                        </div>
                        <p><kbd>R</kbd> Ø¨Ø±Ø§ÛŒ Ø¨Ø§Ø²ÛŒ Ø¬Ø¯ÛŒØ¯ ÙØ´Ø§Ø± Ø¯Ù‡ÛŒØ¯</p>
                    </div>
                `;
                document.body.appendChild(gameOverDiv);
                
                // Add keyboard listener for game over screen
                const gameOverHandler = (event) => {
                    if (event.key.toLowerCase() === 'r') {
                        document.removeEventListener('keydown', gameOverHandler);
                        startNewGame();
                    }
                };
                document.addEventListener('keydown', gameOverHandler);
            }
        }

        // Initialize game
        let game = new WumpusGame();

        // Control functions (kept for potential button controls, though keyboard is primary)
        function move(direction) {
            game.move(direction);
        }

        function shoot() {
            game.shoot();
        }

        function grab() {
            game.grab();
        }
        
        function startNewGame() {
            // Remove game over screen
            const gameOverDiv = document.querySelector('.game-over');
            if (gameOverDiv) {
                gameOverDiv.remove();
            }
            // Create new game with random world
            game = new WumpusGame();
        }
    </script>
</body>
</html>